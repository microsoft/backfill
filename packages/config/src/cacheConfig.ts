import type { Logger } from "backfill-logger";

export interface ICacheStorage {
  fetch: (hash: string) => Promise<boolean>;
  put: (hash: string, filesToCache: string[]) => Promise<void>;
}

export type AzureBlobCacheStorageOptions =
  | AzureBlobCacheStorageConnectionStringOptions
  | AzureBlobCacheStorageContainerClientOptions;

export type AzureBlobCacheStorageConnectionStringOptions = {
  /** Retrieve this from the Azure portal for the blob storage. */
  connectionString: string;
  /** Name of the blob storage container. */
  container: string;
  /** Max size of a single package cache, in bytes. */
  maxSize?: number;
  /** One of the credential types from `@azure/identity`. */
  credential?: TokenCredentialLike;
};

export type AzureBlobCacheStorageContainerClientOptions = Pick<
  AzureBlobCacheStorageConnectionStringOptions,
  "maxSize"
> & {
  /**
   * Pre-created `ContainerClient` from `@azure/storage-blob`, as returned by
   * `BlobServiceClient#getContainerClient`.
   */
  containerClient: ContainerClientLike;
};

// The ___Like types prevent pulling in large trees of azure type dependencies,
// particularly in the lage CLI's types rollup (which includes backfill cache
// options). The objects should be generated by the relevant Azure SDKs, so
// they'll automatically match the full signatures. If the stub signatures
// become mismatched, it should show up when type checking the backfill-cache
// package that uses the Azure SDKs.

/**
 * `ContainerClient` from `@azure/storage-blob`, as returned by
 * `BlobServiceClient#getContainerClient`.
 */
type ContainerClientLike = {
  getBlobClient: (hash: string) => unknown;
};

/** One of the credential types from `@azure/identity`. */
type TokenCredentialLike = {
  getToken: (scopes: string | string[], options?: unknown) => Promise<any>;
};

export type NpmCacheStorageOptions = {
  /** Package name to publish */
  npmPackageName: string;
  /** URL of the npm registry */
  registryUrl: string;
  /** Path to a custom .npmrc file to use in place of `$HOME/.npmrc` */
  npmrcUserconfig?: string;
};

export type AzureBlobCacheStorageConfig = {
  provider: "azure-blob";
  options: AzureBlobCacheStorageOptions;
};

export type NpmCacheStorageConfig = {
  provider: "npm";
  options: NpmCacheStorageOptions;
};

export type CustomStorageConfig = {
  provider: (logger: Logger, cwd: string) => ICacheStorage;
  name?: string;
};

export type CacheStorageConfig =
  | {
      provider: "local";
    }
  | {
      provider: "local-skip";
    }
  | NpmCacheStorageConfig
  | AzureBlobCacheStorageConfig
  | CustomStorageConfig;

const envNames = {
  cacheProvider: "BACKFILL_CACHE_PROVIDER",
  cacheProviderOptions: "BACKFILL_CACHE_PROVIDER_OPTIONS",
};

export function getNpmConfigFromSerializedOptions(
  options: string
): NpmCacheStorageConfig {
  let parsedOptions: NpmCacheStorageOptions;
  try {
    parsedOptions = JSON.parse(options);
  } catch {
    throw new Error(
      `Could not parse ${envNames.cacheProviderOptions} as JSON:\n"${options}"`
    );
  }

  if (
    typeof parsedOptions.npmPackageName !== "string" ||
    typeof parsedOptions.registryUrl !== "string"
  ) {
    throw new Error(
      `Invalid ${envNames.cacheProviderOptions} for ${envNames.cacheProvider}="npm":\n` +
        `Expected: object with string values for keys "npmPackageName", "registryUrl"\n` +
        `Received: "${options}"`
    );
  }

  return {
    provider: "npm",
    options: parsedOptions,
  };
}

export function getAzureBlobConfigFromSerializedOptions(
  options: string
): AzureBlobCacheStorageConfig {
  let parsedOptions: AzureBlobCacheStorageConnectionStringOptions;
  try {
    parsedOptions = JSON.parse(options);
  } catch {
    throw new Error(
      `Could not parse ${envNames.cacheProviderOptions} as JSON:\n"${options}"`
    );
  }

  if (
    typeof parsedOptions.connectionString !== "string" ||
    typeof parsedOptions.container !== "string"
  ) {
    throw new Error(
      `Invalid ${envNames.cacheProviderOptions} for ${envNames.cacheProvider}="azure-blob":\n` +
        `Expected: object with string values for keys "connectionString", "container"\n` +
        `Received: "${options}"`
    );
  }

  if (
    parsedOptions.maxSize !== undefined &&
    typeof parsedOptions.maxSize !== "number"
  ) {
    throw new Error(
      `Invalid ${envNames.cacheProviderOptions} for ${envNames.cacheProvider}="azure-blob":` +
        `expected "maxSize" property to be unspecified or a number; received: ${parsedOptions.maxSize}`
    );
  }

  return {
    provider: "azure-blob",
    options: parsedOptions,
  };
}
